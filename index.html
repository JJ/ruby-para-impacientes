<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
    <meta http-equiv="Content-Language" content="es">
    <meta name="generator" content="Emacs y GitHub">
    <title>Tutorial: Ruby para impacientes</title>
    <meta name="AUTHOR" content="Juan Julián Merelo Guervós">
    <meta name="keywords" content="scripting, programación, Ruby,
				   Perl, por supuesto, manual">
    <meta name="description" content="Introducción rápida al lenguaje Ruby">
    <link rel="stylesheet" type="text/css" href="ruby.css" title="normal">
    <link rel="stylesheet" type="text/css" href="highlight.css" title="normal">
  </head>
<body>

  <h1>Taller de la <a href="http://osl.ugr.es/">Oficina de Software Libre</a>: 
      Ruby para impacientes</h1>


<div class="objetivos"> <ul>
	  
	  <li>Conocer la historia y origenes de este lenguaje</li>
	  
	  <li>Entender los conceptos principales detras del mismo</li> 

	  <li>Conocer y saber usar la sintaxis</li> 

	  <li>Aprender las estructuras de datos y control principales</li>
	  
	  <li>Usar e instalar bibliotecas.</li>

	  <li>Hacer un pequeño programa.</li>

      </ul>
</div>  


<h2><a name="1:t1:intro">¿Ruby? Pero si es muy
  fácil </a> <a href="#1:t1:intro" style="font-size:small">#</a></h2>


  <p>Si es que os suena, posiblemente conozcáis <a href="http://www.ruby-lang.org/">Ruby</a>
  por <a href="http://rubyonrails.org/">Ruby on Rails</a>, un entorno
  web creado a mediados de la primera década del siglo que usa Ruby como lenguaje
  subyacente; mucha gente llega a Ruby desde la derecha (el On Rails)
  y se piensan que es como un lenguaje de macros que imita a Python o
    a Perl o a ambos... pero no es así.</p>

<p>El lenguaje Ruby lo
  creó <a href="https://www.ruby-lang.org/en/about/">Matz, Yukihiro
  Matsumoto</a>, con la intención de que fuera fácil de aprender y se
  pareciera lo más posible a la forma en la que hablan las personas,
  no a cómo las máquinas quieren que hablemos. Y tiene mérito que no
  le haya salido mal del todo, porque las últimas dos veces que
  dijeron eso salió el <a href="http://es.wikipedia.org/wiki/COBOL">COBOL</a> y el <a href="http://es.wikipedia.org/wiki/SQL">SQL</a>. Por otro lado, el nombre Ruby
  puede ser un juego de palabras con las perlas de Perl, o quizás
  no. El propio autor dice que es una mezcla de Python (que es
  anterior, pero no mucho) y Perl con un poco de Lisp y Smalltalk
  espolvoreado para que no falte de nada. </p>

<p>¿Y qué es lo que sale? Pues un lenguaje interpretado, <a href='http://www.rubyfleebie.com/ruby-is-dynamically-and-strongly-typed/'>de tipado
    dinámico y fuerte</a>,
  orientado a objeto, reflexivo, que hasta no hace mucho no era
  demasiado rápido pero que últimamente está experimentando un
  incremento de rendimiento considerable. La versión estable actual es
  la 2.1.1, aunque todavía se usan de forma extensa versiones
  anteriores como la 1.9.3. Por supuesto que por lo que más se le sigue conociendo es
  por Ruby on Rails, pero aplicaciones muy populares como Amarok o <a href="http://sketchup.com/">Sketchup</a> usan
  este lenguaje. Y tú puedes tambien usarlo, si prestas atención y
  haces los ejemplos y actividades de este tutorial, ¿por qué no?</p>


<h2><a name="1:primer">Primer programa </a> <a href="#1:primer" style="font-size:small">#</a></h2>


<div class="aclara"><p>Desde Ubuntu, Guadalinex o
    Debian, haz</p>
 <code>sudo apt-get install ruby irb rubygems  rdoc</code>.

<p>También puedes instalar
  el <a href='https://www.ruby-lang.org/es/downloads/'>Ruby Version
  Manager</a>, que te permite trabajar con diferentes versiones de
  Ruby a la vez:
  <code class='ejemplo'>curl -L https://get.rvm.io | bash -s stable  --ruby</code>
y que se instala directamente como una aplicación de usuario. Trabajar
  de esta forma permite uniformizar las versiones en un equipo de
  trabajo y por supuesto actualizar fácilmente el intérprete
  instalado. Este programa lanza un guión del intérprete de comandos
  y, en algunos casos, te podrá pedir la clave de superusuario,
  aunque la instalación final se hace en tu
  espacio <code>$HOME</code>. Previamente habrás tenido que
  instalar <code>curl</code>, aunque está instalado en las distros
  más habituales; si no encuentra una distribución binaria descargará
  y compilará una nueva distro, por lo que también habrá que tener
  las correspondientes herramientas instaladas (principalmente
  compiladores; una vez más, en la mayoría de los casos ya lo
  están). En <a href='https://rvm.io/rvm/install'>esta página da
    diferentes opciones para instalar RVM con/sin Rails y otra serie
    de opcioens</a>.</p>
</div>

<p>Para programar en Ruby necesitas el editor y el Ruby propiamente
  dicho. Descárgatelo e instálalo, aunque te vendrá bien también
  bajarte <code>irb</code>, un intérprete interactivo que te permitirá
  probar cosas sobre la marcha. Servidor usa Emacs como editor, pero
  cualquier otra cosa también servirá, incluso Notepad. Ahora, si
  quieres ir un poco más allá, te puedes
  descargar <a href="http://www.ibm.com/developerworks/opensource/library/os-rubyeclipse/">
    un plugin para Eclipse</a> o
  el <a href="http://homepage2.nifty.com/sakazuki/rde_en/">RDE, sólo
    para Windows</a>. </p>

<p>Ruby es un intérprete, así que no se "ejecuta" desde el menú. El
  ciclo es el habitual en programas para lenguajes interpretados: se
  escribe y se guarda el programa, nos vamos al directorio donde lo
  hemos guardado, si estamos en Linux/Unix lo hacemos ejecutable
  con <code>chmod +x</code>, y lo ejecutamos. Pero todavía no podemos
  ejecutar nada, porque no hemos visto ningún programa, así que vamos
  con el primero.</p>

<p>En cuanto al intérprete de Ruby que se puede instalar, hay muchas
  opciones; hay varias implementaciones de Ruby, aunque la más
  popular es la <em>oficial</em>, la de Matz (llamada a veces
  MRI). Hay, sin embargo, otras como JRuby (dentro de la máquina
  virtual Java) o
  incluso <a href="http://en.wikipedia.org/wiki/Rubinius">Rubinius</a>
  una versión que trata de implementar la mayor parte de Ruby usando
  el propio lenguaje y diseñada para que sea concurrente. En
  tu ordenador puede que tengas una u otra, aunque también te puedes
  instalar <a href="http://en.wikipedia.org/wiki/Ruby_%28programming_language%29#Implementations">cualquier
    otra</a>.  Aconsejamos que se use la oficial para la distribución
  o bien, como se ha hecho arriba, se instale RVM</p>

<code class="ejemplo"><span class="hl slc">#!/usr/bin/ruby</span>
puts <span class="hl str">"Esto es jauja"</span></code>

<p>La primera línea es la habitual en lenguajes interpretados: le dice
  al intérprete de órdenes de Linux (y al servidor Apache en Windows,
  también) dónde tiene que buscar el intérprete; así que habrá que
  comprobar que efectivamente se encuentra allí
  escribiendo <code>which ruby</code> (sí, en Linux, así que ya no lo
  voy a decir más y asumid directamente que cualquier cosa que diga es
  para Linux a no ser que se diga lo contrario).</p>

<p>Si usamos RVM (lo que aconsejamos vivamente) el programa anterior
  se convertiría en </p>
<code class="ejemplo"><span class="hl slc">#!/usr/bin/env ruby</span>
puts <span class="hl str">"Esto es jauja"</span></code>

  <p>En el que hemos cambiado la primera línea por otra
  que <em>busca</em> en el camino de ejecución un programa que
  corresponda a Ruby; si RVM está bien configurado, el primero que
    aparecerá será la instalación que se haya hecho. En todo caso,
  esta segunda forma es más aconsejable porque es independiente del
  lugar donde esté instalado Ruby, basta con que esté en el camino de ejecución</p>


  <p>La siguiente línea no vacía ya sí está escrita en el lenguaje Ruby (aunque
  usa la misma orden que C, <code>put
  string</code>), pero tampoco es que extrañe demasiado. La cadena va
  entre comillas, se usa el cambio de línea para acabar la sentencia,
    y ya está.</p>

<p>Para ejecutarlo se guarda y se hace lo que se ha dicho antes, no
  voy a repetirlo. Y el resultado será el esperado. También pasará lo
  mismo si lo hacemos desde <code>irb</code>, el intérprete
  interactivo (que también se instala con RVM):</p>
<code class="ejemplo">[jmerelo@leonard ruby-para-impacientes]$ <span class="user">irb</span>
pirb(main):001:0&gt; <span class="user">puts "esto es jauja"</span>
esto es jauja
=&gt; nil</code>

<h2><a name="2:Objetos">Ruby, un lenguaje orientado a objetos </a> <a href="#2:Objetos" style="font-size:small">#</a></h2>
<div class="aclara" style="width:300"><h3>Cuidado con el copy/paste
    para programas en Ruby</h3>

<p>Como Ruby usa la indentación mediante tabuladores para indicar
  bloques, los copia/pega de las páginas web no tienen por qué
  funcionar bien. Es mejor descargar los programas enlazados pulsando
  con el botón de la derecha y <em>salvar como</em> o descargarlos del
  directorio en GitHub</p>

</div>

<p>Pero Ruby es un lenguaje orientado a objetos, o más bien empotrado
  de objetos: todo es un objeto en Ruby. Así que lo anterior (y algo más) podríamos
  escribirlo <a href='code/jauja-center.rb'>de la forma
  siguiente</a>.</p>

<code class="ejemplo">puts <span class="hl str">"--"</span> <span class="hl sym">&lt;&lt;</span> <span class="hl str">"Esto es jauja"</span><span class="hl sym">.</span><span class="hl kwd">center</span><span class="hl sym">(</span><span class="hl num">20</span><span class="hl sym">) &lt;&lt;</span> <span class="hl str">"--"</span></code>

  <p>Lo que consigue este programa es escribir una cadena centrada en
  una línea de 20 caracteres y rodeada por dos guiones
  (<code>--</code>). <code>&lt;&lt;</code> es el operador de 
 concatenación, que pega una cadena a la siguiente. Pero la 
 parte orientada a objetos está alrededor del 
    <code>.center</code> es un método de la 
 clase <a href="http://ruby-doc.org/core/classes/String.html">String</a>, 
 pero como todo es un objeto en Ruby, no hace falta que lo 
 declaremos explícitamente, ya es un objeto de por sí, por lo que
 podemos aplicarle los métodos correspondientes, tales como
 ese. Pasándole el argumento 20, centra la cadena en un espacio
 equivalente a 20
    caracteres:</p>
<code class="ejemplo">usuario@usuario-desktop:~/code$ <span class="user">./jauja-center.rb </span>
--   Esto es jauja    --
</code>

<p>También podíamos haber creado el objeto explícitamente, pero
  hubiera sido mucho más clásico:</p>

<code class="ejemplo">jauja <span class="hl sym">=</span> String<span class="hl sym">::</span><span class="hl kwd">new</span><span class="hl sym">(</span> <span class="hl str">"Esto es jauja"</span> <span class="hl sym">)</span>
puts <span class="hl str">"--"</span> <span class="hl sym">&lt;&lt;</span> jauja<span class="hl sym">.</span><span class="hl kwd">center</span><span class="hl sym">(</span><span class="hl num">20</span><span class="hl sym">) &lt;&lt;</span> <span class="hl str">"--"</span>
</code>

  <p>En la primera línea, en la que definimos una variable llamada <code>jauja</code> vemos un par de cosas: como en otros lenguajes,
las variables en Ruby no tienen ningún  carácter
adicional (en realidad se verán más adelante algunos caracteres, que
    se usan principalmente para resolución de ámbito). Sólo el nombre
de la variable, lo que tiene sentido, porque hace que uno
tenga que escribir menos. Por otro lado, <code>String</code> es una
clase, y además una clase estándar, por lo que no hay que decirle al
programa que la incluya ni nada. El método <code>new</code> es un
método de clase, con lo que la sintaxis para llamarlo, a diferencia del método de un
objeto, es de cuatro puntos (dos puntos dobles). El contenido de la
variable sigue siendo un objeto, así que se usa de la misma forma que
antes. </p>

<p>El resto de los tipos de datos se define también de la forma más
lógica; Ruby trabaja bajo el principio de la mínima sorpresa (lo que
muchas veces provoca sorpresa viniendo de otros lenguajes), o más bien
de la máxima coherencia: una vez aprendida parte del lenguaje, el
resto es más o menos igual. Por ejemplo, las matrices:
<code class="ejemplo">matriz <span class="hl sym">= [</span><span class="hl str">'esto'</span><span class="hl sym">,</span><span class="hl str">'es'</span><span class="hl sym">,</span><span class="hl num">1</span><span class="hl sym">,</span><span class="hl str">'matriz'</span><span class="hl sym">]</span>
puts matriz<span class="hl sym">.</span>join <span class="hl sym">&lt;&lt;</span> <span class="hl str">" "</span> <span class="hl sym">&lt;&lt;</span> matriz<span class="hl sym">.</span><span class="hl kwd">join</span><span class="hl sym">(</span><span class="hl str">"-"</span><span class="hl sym">)</span>
</code>
Como ocurre en otros lenguajes dinámicos como el Ruby, no hay
distinción de tipos, o mejor dicho, hay tipificación dinámica: una matriz puede contener números enteros,
cadenas e incluso otras matrices, y desde su creación son objetos de
pleno derecho, pudiéndosele aplicar métodos como <code>join</code> que
une todos los elementos de la matriz, con o sin algún carácter de por
medio. Este pequeño programa imprimirá:
<code class="ejemplo">usuario@usuario-desktop:~/ruby-para-impacientes$ <span class="user">code/matriz.rb </span>
estoes1matriz esto-es-1-matriz</code>
como, imagino, era de esperar. </p>

<p>No son los únicos tipos de matrices: las matrices asociativas son
  aquellas que usan una clave para acceder a cada uno de los elementos
  (en vez de hacerlo en secuencia), sumamente útiles para evitar la
  distribución de la información de una estructura de datos por
  múltiples matrices y su acceso fácil usando una clave</p>
<code class="ejemplo">sonido_de <span class="hl sym">= { :</span>vaca <span class="hl sym">=&gt;</span> <span class="hl str">'muuu'</span><span class="hl sym">,</span>
	  <span class="hl sym">:</span>buho <span class="hl sym">=&gt;</span> <span class="hl str">'uuu'</span><span class="hl sym">,</span>
	  <span class="hl sym">:</span>caballo <span class="hl sym">=&gt;</span> <span class="hl str">'iiiii'</span> <span class="hl sym">}</span>
puts sonido_de<span class="hl sym">.</span>inspect
</code>

<p>Que, aparte de introducir las llaves (para claves... ¿lo ves como se
	  trata de no sorprender?) pone unos dos puntitos delante de
	  las mismas que la verdad que sí sorprenden. Y es porque se
	  trata de cadenas un poco especiales, denominadas
	  <em>símbolos</em>. Los símbolos en Ruby son como cadenas con las que
	  no se va hacer nada de lo que se suele hacer con las mismas:
	  ni partirlas, ni añadirles nada, ni quitarles nada. Unas
	  cadenas constantes, más o menos, que no es otra cosa lo que
necesitamos en una variable asociativa,
	  denominada <a href="http://ruby-doc.org/core/classes/Hash.html">Hash</a>
	  en Ruby. Por supuesto, se puede usar una cadena normal y
	  corriente como clave:
<code class="ejemplo">precio_de <span class="hl sym">= {</span> <span class="hl str">"pipas"</span> <span class="hl sym">=&gt;</span> <span class="hl str">'bajo'</span><span class="hl sym">,</span>
	  <span class="hl str">"coche"</span> <span class="hl sym">=&gt;</span> <span class="hl str">'depende'</span><span class="hl sym">,</span>
	  <span class="hl str">"plan E"</span> <span class="hl sym">=&gt;</span> <span class="hl str">'exagerado'</span> <span class="hl sym">}</span>
puts precio_de<span class="hl sym">.</span>to_s</code>
que al ejecutarse, por usar <code>to_s</code> para convertir a una
	  cadena la matriz asociativa en vez del inspect anterior no
se ve nada, pero es otra forma de hacer las cosas.</p>

<p>Ruby, aparte de tener tipificación dinámica, también tiene
  tipificación fuerte. Es decir, una vez que se ha establecido el tipo
  de una variable sólo se pueden hacer las operaciones que permita la
  clase. </p>
  <code class='ejemplo'>irb(main):015:0><span class='user'> bar='hola k ase'</span>
=> "hola k ase"
irb(main):016:0><span class='user'>  bar+3</span>
TypeError: can't convert Fixnum into String
	from (irb):16:in `+'
	from (irb):16
	from /usr/bin/irb:12:in `&lt;main>'
irb(main):017:0><span class='user'>  bar=3</span>
=> 3
irb(main):018:0><span class='user'> bar+3 </span>
=> 6</code>

  <p>En el ejemplo anterior primero definimos <code>bar</code> como
    una cadena, lo que fija su tipo a <code>String</code>, por lo que
    no podemos usar la operación de suma y obtenemos el error que se
    indica (no se puede convertir <code>Fixnum</code>
    en  <code>String</code>). Sin embargo, usamos la misma variable
    para asignarle un número y dinámicamente se le asigna ese tipo o
    clase, por lo que ya podemos usarlo para esa operación</p>

<h2><a name="1:es">Entrada y Salida. Y, de camino, bucles. </a> <a href="#1:es" style="font-size:small">#</a></h2>



<p>Tratándose de un lenguaje orientado a objetos, habrá que buscar la
  clase para abrir y cerrar ficheros, que se llama en un alarde de
  originalidad <code>File</code>.
<code class="ejemplo">fh <span class="hl sym">=</span> File<span class="hl sym">::</span><span class="hl kwd">new</span><span class="hl sym">(</span> <span class="hl kwc">ARGV</span><span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">] )</span>
<span class="hl kwa">while</span> <span class="hl sym">(</span>line <span class="hl sym">=</span> fh<span class="hl sym">.</span>gets <span class="hl sym">)</span>
      nombre<span class="hl sym">,</span> apellidos  <span class="hl sym">=</span> line<span class="hl sym">.</span><span class="hl kwd">split</span><span class="hl sym">(</span><span class="hl str">','</span><span class="hl sym">)</span>
      puts <span class="hl str">"* Nombre #{nombre}</span><span class="hl esc">\n\t</span><span class="hl str">apellidos #{apellidos}"</span>
<span class="hl kwa">end</span></code>
En este caso, tampoco es sorprendente la matriz que se usa para
acceder a la línea de comandos: ARGV, igual que en C (pero en
mayúsculas) o en Perl (pero sin dólares). Ya puestos, introducimos
también una esctructura de control: el bucle <code>while</code> que
va leyendo línea a línea con <code>gets</code> (lo contrario
que <code>puts</code>, que es para escribir). El cuerpo del bucle no
usa llaves, sólo la indentación y la palabra <code>end</code> para indicar el
final. </p>

  <p>Fijaros también en una cosa curiosa: el <code>=</code> de la primera línea
  tiene a la izquiera y a la derecha una matriz: dos variables a las
  que se le asigna lo que queda al partir (<code>split</code>) la línea del
  tipo <code>nombre, apellidos</code> por la coma que lo
  divide. Simplemente se ponen a la izquierda las variables a las que
  van a ir a parar los diferentes elementos de la matriz. Y en la
  línea siguiente se imprime la salida, interpolando las cadenas
  usando algo para distinguirlas: <code>#{}</code>. Como las variables
  no tienen ningún símbolo delante, hace falta eso al menos para saber
  que se trata de variables, y no de parte de la cadena. El
  resultado es el esperado:
<code class="ejemplo">$ <span class="user"> ruby code/fichero.rb code/nombres.txt </span>
* Nombre Ginés
	apellidos  Ibn Hassan Rodríguez
* Nombre Sergei
	apellidos  Ben Ayoun
* Nombre Malika
	apellidos  Maliki
* Nombre Juan
	apellidos  Gómez Gómez
</code>
al menos sobre el fichero
</p><pre>Ginés, Ibn Hassan Rodríguez
Sergei, Ben Ayoun
Malika, Maliki
Juan, Gómez Gómez</pre>
<p></p>

<p>Las clases están organizadas jerárquicamente en espacios de
  nombres. <code>Net</code>, por ejemplo, agrupa diferentes funciones
  relacionadas con la red: web , FTP, y todas esas cosas; dentro de
  esa jerarquía, los descendientes se separan con <code>::</code>,
  igual que en
  Perl. <a href="http://augustl.com/blog/2010/ruby_net_http_cheat_sheet/">Net::HTTP</a>
  serviría para leer cosas de la web. Pero no forma parte del núcleo o
  <em>core</em>, así que tendremos que importarla explícitamente con
  require:
<code class="ejemplo"><span class="hl kwa">require</span> <span class="hl str">'net/http'</span>

Net<span class="hl sym">::</span>HTTP<span class="hl sym">.</span>get_print  <span class="hl str">'osl.ugr.es'</span><span class="hl sym">,</span> <span class="hl str">'/'</span>
</code>
En <code>require</code> cambia un poco la sintaxis: se separan las partes de la
librería con <code>/</code> y se pone todo en minúsculas. <code>require</code>
importa el código, pero no los identificadores; por eso para usar
alguna función del módulo hay que decir todo el nombre de la misma:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
nombre de la clase <code> nombre_del_método. <code>get_print</code> es un método
=======
nombre de la clase <code> nombre_del_método</code>. <code>get_print</code> es un método
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
  de clase, y recibe como argumentos el nombre del servidor (el HTTP
  va de soi) y la dirección dentro de ese servidor, en este caso el
  directorio raíz. Al ejecutarlo nos dará de resultado un mogollón de
  texto, todo lo que haya en la página. De camino, conviene fijarse
  que aquí nos hemos ahorrado unos cuantos paréntesis, lo que,
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  sinceramente, me ha sorprendido.</code>

</p><p>Juntando todo lo anterior, y añadiendo alguna cosilla más de
  nuestra cosecha, podemos bajarnos una página web y
  meterlo en un fichero</p>
=======
sinceramente, me ha sorprendido.<p></p>

<p>Juntando todo lo anterior, y añadiendo alguna cosilla más de
  nuestra cosecha, podemos bajarnos una página web y
  meterla en un fichero</p>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
<code class="ejemplo"><span class="hl kwa">require</span> <span class="hl str">'net/http'</span>

url <span class="hl sym">=</span> <span class="hl kwc">ARGV</span><span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">]</span>
respuesta <span class="hl sym">=</span> Net<span class="hl sym">::</span>HTTP<span class="hl sym">.</span>get  url<span class="hl sym">,</span> <span class="hl str">'/'</span>
fname <span class="hl sym">=</span> url <span class="hl sym">+</span> <span class="hl str">".html"</span>
<span class="hl kwa">if</span> <span class="hl sym">(</span> File<span class="hl sym">.</span>writable<span class="hl sym">?(</span>fname<span class="hl sym">) )</span>
   salida <span class="hl sym">=</span> File<span class="hl sym">.</span>new fname<span class="hl sym">,</span> <span class="hl str">"w"</span>
   salida<span class="hl sym">.</span><span class="hl kwd">puts</span><span class="hl sym">(</span> respuesta <span class="hl sym">)</span>
<span class="hl kwa">else</span>
   <span class="hl kwd">puts</span><span class="hl sym">(</span><span class="hl str">'No puedo escribir en '</span> <span class="hl sym">+</span>fname<span class="hl sym">)</span>
<span class="hl kwa">end</span>
</code>
<p>Nuestra cosecha incluye una interrogación y un <code>if</code>, que no
  habíamos visto antes. La interrogación se pone en los métodos que
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  devuelven un valor lógico, verdadero o falso. En este caso, si se
=======
  devuelven un valor lógico, verdadero o falso (valores que tienen un
  tratamiento diferente en Ruby y en otros lenguajes: un valor lógico
  es un valor lógico, no un 0 o una cadena nula). En este caso, si se
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
  trata o no de un fichero sobre el que tengamos derechos de escritura
  (en lo que, al parecer, es un poco peculiar este Ruby). El bloque
  <code>if</code> termina en <code>end</code>, como antes el bucle. Además, hemos usado "w"
  como segundo argumento de <code>File.new</code> para abrirlo para
  escritura. Como se ve, no hace falta cerrarlo. Pa qué, si ya sabe
  hacerlo el ordenador. </p>

<h2><a name="1:bloques">4 Bloques </a> <a href="#1:bloques" style="font-size:small">#</a></h2>



<p>Después de las variables uno de los conceptos importantes en Ruby
  son los bloques. Un bloque es una secuencia de código con sus
  propias variables, y en Ruby se denota por
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  llaves <code>{}</code> o por <code>def</code> - <code>done</code>. Se usa, por ejemplo, para un bucles tales como los siguientes.</p>
=======
  llaves <code>{}</code> o por <code>do</code> - <code>done</code>. Se usa, por ejemplo, para bucles tales como los siguientes.<p></p>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
<code class="ejemplo">host <span class="hl sym">=</span> <span class="hl kwc">ARGV</span><span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">]</span>
partes <span class="hl sym">=</span> host<span class="hl sym">.</span><span class="hl kwd">split</span><span class="hl sym">(</span><span class="hl str">"."</span><span class="hl sym">)</span>
partes<span class="hl sym">.</span>each <span class="hl kwa">do</span> <span class="hl sym">|</span>p<span class="hl sym">|</span>
  puts <span class="hl str">"* #{p}"</span>
<span class="hl kwa">end</span>
</code>
<p>En este mini-programa le pasamos un nombre de servidor en internet 
(del tipo subdominio.dominio.tld) y nos da cada una de sus partes, que 
se guardan precisamente en una variable que se llama así. Pero el truco 
está en la tercera línea: <code>partes.each</code> es una función que recibe un bloque como argumento. También lo podríamos expresar de la forma siguiente:
<code class="ejemplo">partes <span class="hl sym">=</span> host<span class="hl sym">.</span><span class="hl kwd">split</span><span class="hl sym">(</span><span class="hl str">"."</span><span class="hl sym">)</span>
partes<span class="hl sym">.</span>each <span class="hl sym">{ |</span>p<span class="hl sym">|</span>
  puts <span class="hl str">"* #{p}"</span>
<span class="hl sym">}</span>
</code>
y sería exactamente lo mismo (salvo la precedencia, pero eso no nos importa ahora). </p>

<p>Los bloques tienen todos la misma estructura: al principio se
  declara una variable, que será la variable que irá tomando los
  valores que reciba de su función uno por uno. En este caso la hemos
  llamado <code>p</code>, pero es un nombre arbitrario, porque estamos haciendo
  una declaración. Dentro ya del bloque metemos el código que
  consideremos necesario, y lo finalizamos con llaves o end,
  dependiendo de cómo lo hayamos comenzado</p>

<p>Lo que ocurre con los bloques en Ruby es que tienen entidad
  propia. Son como funciones anónimas, y de hecho se pueden usar como
  tales; además, como todo en Ruby, son objetos, o sea que podemos
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  crearlos y pasarlos por ahi como queramos. 
=======
  crearlos y pasarlos por ahí como queramos. 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
<code class="ejemplo">prefijos <span class="hl sym">= %</span><span class="hl kwd">w</span><span class="hl sym">(</span> pre post ante <span class="hl kwa">super</span> macro mega<span class="hl sym">)</span>
prefijadores <span class="hl sym">=</span> Hash<span class="hl sym">.</span>new
prefijos<span class="hl sym">.</span>each <span class="hl sym">{ |</span>p<span class="hl sym">|</span>
  prefijadores<span class="hl sym">[</span>p<span class="hl sym">] =</span> lambda <span class="hl sym">{ |</span>post<span class="hl sym">|</span> <span class="hl kwa">return</span> <span class="hl str">"#{p}#{post}"</span><span class="hl sym">;}</span>
<span class="hl sym">}</span>

puts prefijadores<span class="hl sym">[</span><span class="hl str">'macro'</span><span class="hl sym">].</span><span class="hl kwd">call</span><span class="hl sym">(</span> <span class="hl str">'objetivo'</span> <span class="hl sym">)</span>
puts prefijadores<span class="hl sym">[</span><span class="hl str">'super'</span><span class="hl sym">].</span><span class="hl kwd">call</span><span class="hl sym">(</span> <span class="hl str">'chanchi'</span> <span class="hl sym">)</span>
puts prefijadores<span class="hl sym">[</span><span class="hl str">'mega'</span><span class="hl sym">].</span><span class="hl kwd">call</span><span class="hl sym">(</span> <span class="hl str">'chuli'</span> <span class="hl sym">)</span>
</code>
En este ejemplo hemos empezado definiendo una matriz de forma
abreviada: usando <code>%w</code> para ahorrarnos comas y comillas, y
hemos seguido creando un <code>Hash</code> (matriz asociativa) donde vamos a
guardar todas las funciones. Recorriendo el array creado y usando
<code>lambda</code> creamos una función que tiene una parte fija, <code>p</code> que recibe
del bucle, y una parte variable, <code>post</code>, que es el argumento que
recibirá cuando se llame, tal como se hace abajo usando <code>call</code>
(recordad que es un objeto, y para ejecutar esa función hay que llamar
al método <code>call</code> de ese objeto). La
función <code>prefijadores['macro']</code> se comportará de la misma
forma que si la hubiéramos definido así
<code class="ejemplo"><span class="hl kwa">def</span> <span class="hl kwd">prefijador</span><span class="hl sym">(</span> post <span class="hl sym">)</span>
  <span class="hl str">"macro#{post}"</span><span class="hl sym">;</span>
<span class="hl kwa">end</span>

puts <span class="hl kwd">prefijador</span><span class="hl sym">(</span><span class="hl str">'micro'</span><span class="hl sym">);</span>
</code>
la única diferencia es que en este caso no hace falta usar <code>call</code> para
llamar a la función: se puede usar directamente el nombre de la
misma. De camino, vemos como se definen funciones en ruby: usando
también <code>def</code>. Igual que antes, salvo que ahora damos un nombre al
bloque, lo que le da más derechos, al parecer.</p>

<h2><a name="1:cpan">Instalando nuevos módulos </a> <a href="#1:cpan" style="font-size:small">#</a></h2>



<p>Qué sería de cualquier lenguaje si tuviéramos que conformarnos con
  lo que nos da, y no pudiéramos instalar cosas nuevas... comenzó
  LaTeX con CTAN, luego siguió Perl con CPAN, y Ruby tiene su
  colección de gemas para poder bajártelas cómodamente. En la mayor
  parte de las distribuciones incluidas hoy en día, o en cualquier
  caso a partir de la 1.9, es parte del mismo paquete que Ruby, así
  que no hace falta descargárselo aparte. Si no es el caso, lo mejor
  es usar el entorno RVM como se ha explicado anteriormente.</p>

<p>Aparte de gem, hay que instalarse alguna cosa más, porque muchos
  módulos en ruby necesitan herramientas de construcción
  adicionales. En concreto, la versión <code>-dev</code> del paquete
  Ruby que tengamos instalado. Por ejemplo, en Ubuntu habría que
  escribir 
  <code class="ejemplo">sudo apt-get install ruby1.8-dev</code>
No siempre es necesario, pero si te da un error algún módulo típico,
  posiblemente sea por eso.</p>

<p>Una vez instalado todo eso, no hay más que usarlo. Empezamos por
  buscar algo que queramos instalar:</p>
<code class="ejemplo">jmerelo@sheldon:~/public_html/tutoriales/ruby-para-impacientes$
  <span class="user">gem search mysql</span>

*** LOCAL GEMS ***
</code>
<p>Joeves, no devuelve nada. Pero claro, es que busca en la colección
  local de gemas. Habrá que buscar en la remota:</p>
<code class="ejemplo">
jmerelo@sheldon:~/public_html/tutoriales/ruby-para-impacientes$ <span class="user">gem search --remote mysql</span>

*** REMOTE GEMS ***

activerecord-jdbcmysql-adapter (0.9.6)
activerecord-mysql-adapter-flags (0.0.3)
dbd-mysql (0.4.4)
do_mysql (0.10.1)
...
</code>
<p>Y así hasta un mogollón de cosas. Tendremos un listado de todas las
  disponibles, y todas las versiones. Vamos a instalarnos la tercera;
  si queremos que esté disponible para todos los usuarios tendremos
  que lanzar la orden con privilegios de administrador:</p>
<code class="ejemplo">jmerelo@sheldon:~/ruby-para-impacientes$ <span class="user">sudo gem install ruby-mysql</span>
Successfully installed ruby-mysql-2.9.2
1 gem installed
Installing ri documentation for ruby-mysql-2.9.2...
Installing RDoc documentation for ruby-mysql-2.9.2...
Could not find main page README
Could not find main page README
Could not find main page README
Could not find main page README
</code>
<p>En algunos casos puede que dé error, porque falte alguna
  dependencia que haya que instalar desde el sistema operativo; en ese
  caso, es conveniente instalar el paquete correspondiente, en vez de
  hacerlo desde <code>gem</code>. Si no es la ultimísima versión luego se puede
  actualizar con gem update. Por ejemplo, un paquete de mysql se puede
  instalar con <code>sudo apt-get install libdbd-mysql-ruby</code>;
  posteriormente, al hacer <code>gem update</code> se actualizará
  alguna de las librerías dependientes que se han instalado con el
  paquete (en mi caso, sólo una denominada <code>deprecated</code>)</p>


<h2><a name="1:hpricot">6 Rascando HTML: hpricot </a> <a href="#1:hpricot" style="font-size:small">#</a></h2>



<p>Hay verdaderas virguerías entre los paquetes gem, pero uno de los
  más útiles para los que nos dedicamos
  a <acronym name="scraping">rascar HTML</acronym>
  es <a rhef="http://hpricot.com/">hpricot</a>, un analizador
  <em>liberal</em> de HTML que permite extraer información de las páginas
  muy fácilmente. Lo instalamos con gem (<code>sudo gem install
    hpricot</code>) y podemos empezar a usarlo</p>
<code class="ejemplo"><span class="hl kwa">require</span> <span class="hl str">'rubygems'</span>
<span class="hl kwa">require</span> <span class="hl str">'hpricot'</span>
<span class="hl kwa">require</span> <span class="hl str">'open-uri'</span>

osl <span class="hl sym">=</span>  <span class="hl kwd">Hpricot</span><span class="hl sym">(</span><span class="hl kwd">open</span><span class="hl sym">(</span><span class="hl str">"http://osl.ugr.es/"</span><span class="hl sym">))</span>
osl<span class="hl sym">.</span><span class="hl kwd">search</span><span class="hl sym">(</span><span class="hl str">"//h2[@class='entry-title']"</span><span class="hl sym">).</span>each <span class="hl sym">{ |</span>h2<span class="hl sym">|</span>
  this_h2 <span class="hl sym">=</span> <span class="hl kwd">Hpricot</span><span class="hl sym">(</span> h2<span class="hl sym">.</span>to_s <span class="hl sym">)</span>
  link <span class="hl sym">=</span> this_h2<span class="hl sym">.</span><span class="hl kwd">search</span><span class="hl sym">(</span><span class="hl str">"a[@href]"</span><span class="hl sym">).</span>inner_html
  text <span class="hl sym">=</span> this_h2<span class="hl sym">.</span><span class="hl kwd">at</span><span class="hl sym">(</span><span class="hl str">"a"</span><span class="hl sym">).</span>inner_html
  puts <span class="hl str">"#{link} =&gt; #{text}"</span>
<span class="hl sym">}</span></code>
<p>Hay que incluir unos cuantos módulos; a partir de ahí se trata de
  usar expresiones XPath (hay que saber un poco de XML para esto, pero
  es bastante lógico todo) y de usar <code>inner_html</code> para
  extraer el interior de los elementos que vamos analizando, en este
  caso los enlaces y títulos de los titulares del blog de
  la <a href="http://osl.ugr.es/">OSL</a>. Por ejemplo, en este caso
  le estamos diciendo que extraiga los elementos <code>h2</code> que, además,
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  tengan como atributo <code>class</code> <code>entry-title</code> </p>

=======
  tengan como atributo <code>class</code> <code>entry-title</code>; y lo estamos
      haciendo pasándole un bloque con las cosas que tiene que hacer
      cada vez que se encuentre con un elemento que cumpla esa
      condición.  <p></p>

<p>Por cierto, no es la única forma de hacer <em>scraping</em> con
      Ruby: se <a href="http://muharem.wordpress.com/2007/09/04/scrape-the-web-with-ruby/">puede
      usar también WWW::Mechanize</a>, una versión de la librería en Perl.</p>
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b

<h2><a name="1:t1:biblio">7 Bibliografía </a> <a href="#1:t1:biblio" style="font-size:small">#</a></h2>



<iframe src="index_files/cm_002.html" style="width:120px;height:240px;float:left" marginwidth="0" marginheight="0" scrolling="no" frameborder="0"></iframe>  <p>Como es de esperar, hay libros enteros gratuitos sobre
    Ruby: <a href="http://ruby-doc.org/docs/ProgrammingRuby/">Programming
      Ruby</a>, por ejemplo, pero el más curioso
    es <a href="http://mislav.uniqpath.com/poignant-guide/">la guía
      intensa de Why's a Ruby</a>, con cómics, vericuetos inefables,
    pero que finalmente termina enseñando bastante. También tienes
    este <a href="https://www.ruby-lang.org/en/documentation/quickstart/">tutorial
      en 20 minutos</a>, y los libros que te aparecen a ambos lados
    de este texto.</p>
<iframe src="index_files/cm_002.html" style="width:120px;height:240px;float:right" marginwidth="0" marginheight="0" scrolling="no" frameborder="0"></iframe>

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
=======
<p>Como seguramente conoces otro lenguaje de programación, prueba <a href="https://www.ruby-lang.org/es/documentation/ruby-from-other-languages/">Ruby
	desde otros lenguajes</a>, con tutoriales en inglés y español
      que explican cómo trabajar  con Ruby si se conoce Perl, o Java,
	o Python.</p>

&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3bd00d4f0b77bb8b520e874d7ea3febf1d4bf23b
<p>En español se puede
  mirar <a href="http://rubytutorial.wikidot.com/">este tutorial de
  Ruby</a>, bastante completo,
  o <a href="http://rubytutorial.wikidot.com/ruby-15-minutos">este
  resumen</a> para aprender en sólo 15 minutos. También hay
  traducciones de todos los libros anteriores, y si quieres meterte
  más a fondo, tienes <a href="http://todoruby.blogspot.com/">este
  blog</a> para
  seguir. Esta <a href="http://www.demiurgo.org/charlas/ruby.pdf">presentación
    también está bien</a>, aunque le falta detalle; es bastante
  buena, en general, e instructiva. </p>

<p>Cuando ya estés harto de
  Ruby, <a href="http://www.maestrosdelweb.com/editorial/rubyonrails/">también
    puedes aprender un poquico de Ruby on Rails</a>, ya puesto. </p>



<br clear="all">

<div class="licencia">Este material está <a href="http://curso-sobre.berlios.de/gfdles/">disponible bajo los términos de la licencia GNU FDL</a>. </div>

<div style="float:right">
      <a href="http://validator.w3.org/check?uri=referer"><img src="index_files/valid-html401.png" alt="Valid HTML 4.01 Transitional" width="88" height="31"></a>
    </div>
    
    <address><a href="mailto:jj%20%28at%29%20merelo.net">Juan J. Merelo</a></address>
  





</body></html>
